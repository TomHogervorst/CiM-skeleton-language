FuncBlock(add, (40,32), 180, 125, ((0,0), 90, 1)((0,32), 270, 0), ((40,0), 90, 0));
FuncBlock(mul, (256,160), 804, 137, ((0,80), 90, 1)((0,0), 90, 1), ((256,160), 270, 1));
FuncBlock(subt, (40,32), 180, 125, ((0,0), 90, 1)((0,32), 270, 0), ((40,0), 90, 0));
FuncBlock(div, (201,280), 6064, 5190, ((0,32), 90, 1)((0,96), 270, 0), ((201,248), 270, 1));
FuncBlock(gt, (128, 192), 27, 93, ((0,0), 90, 1)((0,64), 90, 1), ((128, 192), 270, 1));
FuncBlock(mux2, (96, 97), 5, 22, ((0,1), 90, 1)((0,33), 90, 1)((0,0), 0, 0), ((96,97), 270, 1));
FuncBlock(LUT, (405,106), 7, 603, ((0,0), 90, 1)((0,37), 90, 1),((405,106), 270, 1));
FuncBlock(GO, (288,256), 36, 67, ((0,0), 90, 1)((0,256), 270, 0),((288,97), 270, 1));
FuncBlock(gap, (40,32), 180, 125, ((0,0), 90, 1), ((40,0), 90, 0));
FuncBlock(sort2, (288,256), 36, 137, ((0,0), 90, 1)((0,256), 270, 0), ((288,97), 270, 1)((288,191), 90, 0));
FuncBlock(NW, (1022, 429), 441, 1112, ((0, 0), 90, 1) ((0, 138), 90, 1) ((0, 0), 0, 0)  ((32, 0), 0, 0)  ((64, 0), 0, 0),  ((1022, 0), 90, 0) ((32, 428), 180, 1) ((893, 427), 0, 0) ((925, 97), 90, 1));

component main<in[8] | out[8]>(){
	int t;
	t = 3;

	in[0:2^t] => bitonic_sort(t, 0) => out[0:2^t];
}

component bitonic_sort<in[2^n] | out[2^n]>(int n, int inv){
	int i;
	int j;
	if n== 1 then
		in[0:2] => sort2(inv) => out[0:2];
	else 
		in[0:2^n] => bitonic_sort(n-1, 0) ++ bitonic_sort(n-1, 1) *_I_* 
			perfect_shuffle(n) *_I_* bitonic_merge(n, inv) => out[0:2^n];
}

component bitonic_merge<in[2^n] | out[2^n]>(int n, int inv){
	if n==1 then 
		in[0:2] => sort2(inv) => out[0:2];
	else
		in[0:2^n] => copy[2^(n-1)](sort2(inv)) *_I_* butterfly(n) *_I_* bitonic_merge(n-1, inv) ++ bitonic_merge(n-1, inv) => out[0 : 2^n];
}

component perfect_shuffle<in[2^n] | out[2^n]>(int n){
	int Psize;
	Psize = 2^n;
	zip(in[0:Psize/2], in[Psize/2 : Psize]) => out[0:2^n];
}

component butterfly<in[2^n] | out[2^n]>(int n){
	int Bsize;
	Bsize = 2^n;
	zip(in[0:2:Bsize/2], in[Bsize/2:2:Bsize]) ++ zip(in[1:2:Bsize/2], in[1 + Bsize/2:2:Bsize]) => out[0:Bsize];
}

component sort2<in[2] | out[2]>(int inv){
	if inv == 0 then
		in[{0, 0, 1, 1}] => NOP ++ gt ++ NOP *_I_* select_connection() *_I_* copy[2](mux2) => out[0:2];
	else
		in[{0, 0, 1, 1}] => NOP ++ gt ++ NOP *_I_* select_connection() *_I_* copy[2](mux2) => out[2:0];
}

component select_connection<in[3] | out[6]>(){
	in[{0, 2, 1}] ++ in[{2, 0, 1}] => out[0:6];
}