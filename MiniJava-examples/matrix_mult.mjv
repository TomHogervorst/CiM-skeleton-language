LibMod(add, (60,80), 20, 125, ((0,0), 0, 0)((32,80), 180, 0), ((60,24), 90, 0));
LibMod(mul, (120,160), 30, 134, ((0,0), 0, 0)((32,160), 180, 0), ((120,64), 90, 0));
LibMod(subt, (40,32), 180, 125, ((0,0), 90, 1)((0,32), 270, 0), ((40,0), 90, 0));
LibMod(div, (201,280), 6064, 5190, ((0,0), 90, 1)((0,280), 270, 0), ((128,0), 90, 0));
LibMod(gt, (128, 192), 27, 93, ((0,0), 90, 1)((64,0), 90, 1), ((128, 192), 270, 1));
LibMod(mux2, (96, 97), 5, 22, ((0,1), 90, 1)((0,33), 90, 1)((0,0), 0, 0), ((96,97), 270, 1));
LibMod(LUT, (405,106), 7, 603, ((0,0), 90, 1)((0,37), 90, 1),((405,106), 270, 1));
LibMod(GO, (288,256), 36, 67, ((0,0), 90, 1)((0,256), 270, 0),((288,97), 270, 1));
LibMod(gap, (40,32), 180, 125, ((0,0), 90, 1), ((40,0), 90, 0));
LibMod(sort2, (80,100), 20, 67, ((0,0), 90, 1)((0,100), 270, 0), ((80,0), 90, 0)((80,100), 270, 1));
LibMod(NW, (400, 100), 200, 500, ((0, 0), 90, 1) ((0, 32), 90, 1) ((0, 0), 0, 0)  ((32, 0), 0, 0)  ((64, 0), 0, 0),  ((400, 0), 90, 0) ((32, 100), 0, 1) ((368, 100), 180, 0) ((400, 32), 90, 0));

component main<in[8] | out[1]>(){
	int n = 2;
	 //in[0:2*n^2] => matrix_mult(n) => out[0:n^2];
	//in[0:n+1] => row(n) => out[0:n];
	in[0:8] => repeat[4](add) *_H_* {add, add} *_H_* add => out[0];
}


//matrix multiplication for nxn matrix
component matrix_mult<A[n^2], B[n^2] | out[n^2]>(int n){
	
	int i = 0;
	loop<++>(i=0:n^2; A[i/n*n:i/n*n+n] ++ B[i%n:n:i%n+n^2]) => repeat[n^2/2](inner_product(n)) *_C_* repeat[n^2/2](inner_product(n)) => out[0 : n^2];
}

component row<a[1], b[n] | out[n]>(int n){
	int i;
	for i=0:n do
		a[0] ++ b[i] => inner_product(n) => out[i];
	end;
}

component inner_product<a[n], b[n] | out[1]>(int n){
	zip(a[0 : n], b[0:n]) => recur(n, mul, add) => out[0];
}

component recur<in[2*n] | out[1]>(int n, comp combiner, comp reducer){
	int i;
	in[0:2*n] => repeat[n](combiner)*_H_* foldr<*_H_*>(map<i = repeat[i](reducer)>(logsof2(n))) => out[0];
}

