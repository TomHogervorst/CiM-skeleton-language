module skeleton-trans

imports

  libstratego-gpp
  lib/runtime/tmpl/pp
  src-gen/signatures/Expression-sig
  src-gen/signatures/System-sig
  src-gen/signatures/IntPair-sig
  src-gen/signatures/Block-sig
  src-gen/signatures/Module-sig
  lib
  gen-dfg
  libmod-trans
  exp-trans
  system-trans
  module-trans
  block-trans
  program-trans
  component-trans
  intpair-trans
  helper

rules
			  
	skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*):
		Connect(skel*, HTree(), r) -> (sys*, n*)
		with
			(preSys*, preN*) := <skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*)> r
			; (postSys*, postN*) := <skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*)> skel*
			; [numInt] := <take(|1)> postN*
			; if <gt> (numInt, <mul> (2, <last> preN*))
			  then <debug(!"The number is too large:")> numInt
			  end
			; sys* := <conc> (preSys*, postSys*)
			; n* := <conc> (preN*,postN*)
			  
	skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*):
		[skel | skels*] -> (sys*, n*)
		with
		(thisSys*, thisN*) := <skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*)> skel;
		(thatSys*, thatN*) := <skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*)> skels*;
		sys* := <merge-trees> (thisSys*, thisN*, thatSys*, thatN*);
		n* := <uneven-zip(add)>(thatN*, thisN*)
	
	skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*):
		LibModNum(val) -> (sys*, n*)
		with
			sys* := [<ast-to-dfg(|ast, systemTuples*, skeletonList*); rotate-outport(|ast); add-tree-mirrors(|ast); system-move-to-origin(|ast)> LibModNum(val)];
			n* := [1]
			
	skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*):
		Nop() -> (sys*, n*)
		with
			sys* := [<ast-to-dfg(|ast, systemTuples*, skeletonList*); system-rotate(|-90)> Nop()];
			n* := [1]
			
	skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*):
		CompRef(x, sizes) -> (sys*, n*)
		with
			system := <lookup>(x, systemTuples*);
			if <eq>(<system-get-input-num> system, 2) then
				if <eq>(<system-get-output-num> system, 1) then
					sys* := [system];
					n* := [1]
				else
					<debug(!"Not a 2 to 1 component: "); fail> system
				end
			else
				<debug(!"Not a 2 to 1 component: "); fail> system
			end
			
	skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*):
		[] -> (sys*, n*)
		with
			sys* := [];
			n* := []
		
	skeleton-get-tree-structure(|ast, systemTuples*, skeletonList*):
		ske -> <debug(!"Not a structured tree: "); fail> ske
		
	rotate-outport(|ast):
		System(mods*, inports*, outports*, size, time, energy) -> System(resMods*, inports*, outports*, size, time, energy)
		with
			outputPort1 := <index(|1)> outports*;
			modNum := <intpair-getx; string-to-int> outputPort1;
			portNum := <intpair-gety; string-to-int> outputPort1;
			outport := <get-libmod(|<index(|modNum); module-get-id; string-to-int> mods*); libmod-get-output(|portNum)> ast;
			angle := <mod>(<add>(<rotate-to(|90, 0)> outport, 360), 360);
			newMods* := <map(module-rotate(|angle))> mods*;
			if <eq> (angle, 180) then
				flippedMods* := <map(module-flip)> newMods*;
				pos := <modules-get-bottom-left(|ast)> flippedMods*;
				resMods* := <modules-transform> (flippedMods*, Block(<intpair-neg> pos, "0", "0"))
			else
				pos := <modules-get-bottom-left(|ast)> newMods*;
				resMods* := <modules-transform> (newMods*, Block(<intpair-neg> pos, "0", "0"))
			end
			
	add-tree-mirrors(|ast):
		System(mods*, inports*, outports*, size, time, energy) -> System(resMods*, resInports*, resOutports*, resSize, time, energy)
		with
			modId := <index(|1); module-get-id; string-to-int> mods*;
			modBlock := <index(|1); module-get-block> mods*;
			inport1 := <get-libmod(|modId); libmod-get-input(|1); block-inherit(|modBlock)> ast;
			inport2 := <get-libmod(|modId); libmod-get-input(|2); block-inherit(|modBlock)> ast;
			(newMods*, resInports*, resOutports*) := <add-tree-mirrors(|mods*, inports*, outports*, size)>(inport1, inport2);
			resBL := <modules-get-bottom-left(|ast)> newMods*;
			resSize := <intpair-sub>(<modules-get-top-right(|ast)> newMods*, resBL);
			resMods* := <modules-shift-to-origin(|ast)> newMods*
			
	add-tree-mirrors(|mods*, inputs*, outputs*, size):
		(Block(loc1, rot1, mir1), Block(loc2, rot2, mir2)) -> (resMods*, resInputs*, resOutputs*)
		with
			newRot1 := <mod>(<add>(<string-to-int> rot1, <mul>(<string-to-int> mir1, 180)), 360);
			newRot2 := <mod>(<add>(<string-to-int> rot2, <mul>(<string-to-int> mir2, 180)), 360);
			difference := <mod>(<subt; abs>(newRot1, newRot2), 360);
			BL1 := <block-get-bottom-left(|IntPair("32", "1"))> Block(loc1, rot1, mir1);
			BL2 := <block-get-bottom-left(|IntPair("32", "1"))> Block(loc2, rot2, mir2);
			if <eq>(newRot1, 90) then
				(newMods*, newInputs*, newOutputs*) := <add-mirrors(|mods*, 0, 1, inputs*, outputs*, 0, 0, IntPair("0", "1"))>(Block(BL1, "0", "1"), [Block(loc1, rot1, mir1)]);
				leftSize := 0;
				rightSize := 1
			else if <eq>(newRot1, 270) then 
				(newMods*, newInputs*, newOutputs*) := <add-mirrors(|mods*, 0, 1, inputs*, outputs*, 0, 0, IntPair("0", "1"))>(Block(BL1, "180", "0"), [Block(loc1, rot1, mir1)]);
				leftSize := 1;
				rightSize := 0
			else if <eq>(newRot1, 180) then
				(newMods*, newInputs*, newOutputs*) := <add-mirrors(|mods*, 0, 1, inputs*, outputs*, 0, 0, IntPair("0", "1"))>(Block(IntPair("0", "0"), "180", "0"), [Block(loc1, rot1, mir1)]);
				leftSize := 1;
				rightSize := 0
			else
				(newMods*, newInputs*, newOutputs*) := (mods*, inputs*, outputs*);
				leftSize := 0;
				rightSize := 0
			end end end;
			if <eq>(newRot2, 90) then
				(resMods*, resInputs*, resOutputs*) := <add-mirrors(|newMods*, 0, 2, newInputs*, newOutputs*, 0, 0, IntPair("0", "1"))>(Block(BL2, "0", "0"), [Block(loc2, rot2, mir2)])
			else if <eq>(newRot2, 270) then 
				(resMods*, resInputs*, resOutputs*) := <add-mirrors(|newMods*, 0, 2, newInputs*, newOutputs*, 0, 0, IntPair("0", "1"))>(Block(BL2, "180", "1"), [Block(loc2, rot2, mir2)])
			else if <eq>(newRot2, 0) then
				(resMods*, resInputs*, resOutputs*) := <add-mirrors(|newMods*, 0, 2, newInputs*, newOutputs*, 0, 0, IntPair("0", "1"))>(Block(IntPair("0", "0"), "0", "0"), [Block(loc2, rot2, mir2)])
			else
				(resMods*, resInputs*, resOutputs*) := (newMods*, newInputs*, newOutputs*)
			end end end
			
	add-lin-mirrors(|ast):
		System(mods*, inports*, outports*, size, time, energy) -> System(resMods*, resInports*, resOutports*, resSize, time, energy)
		with
			(newMods*, resInports*, newOutports*, newSize) := <add-lin-in-mirrors(|ast, 1)>(mods*, inports*, outports*, size);
			(resMods*, resOutports*, resSize) := <add-lin-out-mirrors(|ast, 1)>(newMods*, newOutports*, newSize)
			
	add-lin-in-mirrors(|ast, inputNum):
		(mods*, inports*, outports*, size) -> (resMods*, resInports*, resOutports*, resSize)
		with
			if <index(|inputNum)> inports* then
				inport := <index(|inputNum); input-get-inputs> inports*;
				(newMods*, newInports*, newOutports*, newSize) := <add-mirrors-from-inputs(|ast, mods*, inports*, outports*, size)> inport;
				(resMods*, resInports*, resOutports*, resSize) := <add-lin-in-mirrors(|ast, <inc> inputNum)> (newMods*, newInports*, newOutports*, newSize)
			else
				(resMods*, resInports*, resOutports*, resSize) := (mods*, inports*, outports*, size)
			end
			
	add-mirrors-from-inputs(|ast, mods*, inports*, outports*, size):
		[inport | array*] -> (resMods*, resInports*, resOutports*, resSize)
		with
			modNum := <intpair-getx; string-to-int> inport;
			if <eq>(modNum, 0) then
				(resMods*, resInports*, resOutports*, resSize) := <add-mirrors-from-inputs(|ast, mods*, inports*, outports*, size)> Input(inports*)
			else
				portNum := <intpair-gety; string-to-int> inport;
				modId := <index(|modNum); module-get-id; string-to-int> mods*;
				modBlock := <index(|modNum); module-get-block> mods*;
				port := <get-libmod(|modId); libmod-get-input(|portNum); block-inherit(|modBlock)> ast;
				(newMods*, newInports*, newOutports*, newSize) := <add-lin-in-mirror(|mods*, inports*, outports*, size, modNum, portNum)>port;
				(resMods*, resInports*, resOutports*, resSize) := <add-mirrors-from-inputs(|ast, newMods*, newInports*, newOutports*, newSize)> array*
			end
			
	add-mirrors-from-inputs(|ast, mods*, inports*, outports*, size):
		[] -> (mods*, inports*, outports*, size)
			
	add-lin-out-mirrors(|ast, outputNum):
		(mods*, outports*, size) -> (resMods*, resOutports*, resSize)
		with
			if <index(|outputNum)> outports* then
				outport := <index(|outputNum)> outports*;
				modNum := <intpair-getx; string-to-int> outport;
				portNum := <intpair-gety; string-to-int> outport;
				modId := <index(|modNum); module-get-id; string-to-int> mods*;
				modBlock := <index(|modNum); module-get-block> mods*;
				port := <get-libmod(|modId); libmod-get-output(|portNum); block-inherit(|modBlock)> ast;
				(newMods*, newOutports*, newSize) := <add-lin-out-mirror(|mods*, outports*, size, modNum, portNum)>port;
				(resMods*, resOutports*, resSize) := <add-lin-out-mirrors(|ast, <inc> outputNum)> (newMods*, newOutports*, newSize)
			else
				(resMods*, resOutports*, resSize) := (mods*, outports*, size)
			end
			
	add-lin-in-mirror(|mods*, inports*, outports*, size, modNum, portNum):
		Block(loc, rot, mir) -> (resMods*, resInports*, resOutports*, resSize)
		with
			newRot := <mod>(<add>(<mul>(<string-to-int>mir, 180), <string-to-int>rot), 360);
			if <eq> (newRot, 90) then
				<debug>"Cannot map linear skeleton with modules with inports on the same side as the first output port."
			else if <eq> (newRot, 270) then
				resMods* := mods*;
				resInports* := inports*;
				resOutports* := outports*;
				resSize := size
			else if <eq> (newRot, 0) then
				newMods* := <map(increase-module-num-by(gt|1, 0))> mods*;
				thisMod := <index(|modNum)> newMods*;
				newMod := <module-set-source(|portNum, IntPair("1", "1"))> thisMod;
				newerMods* := <set-index>(<dec> modNum, newMod, newMods*);
				resMods* := <add-mirror(|loc, "0", "1", <tuple-to-intpair>(0, portNum), <index(|modNum)> newerMods*)> newerMods*;
				newInports* := <map(input-addx(|1))> inports*;
				resInports* := <set-index>(<subt>(portNum, 1), Input([IntPair("1", "1")]), newInports*);
				resOutports* := <map(intpair-addX(|1))> outports*;
				resSize := <intpair-addY(|32)> size
			else
				newMods* := <map(increase-module-num-by(gt|1, 0))> mods*;
				thisMod := <index(|modNum)> newMods*;
				newMod := <module-set-source(|portNum, IntPair("1", "1"))> thisMod;
				newerMods* := <set-index>(<dec> modNum, newMod, newMods*);
				resMods* := <add-mirror(|loc, "0", "0", <tuple-to-intpair>(0, portNum), <index(|modNum)> newerMods*)> newerMods*;
				newInports* := <map(input-addx(|1))> inports*;
				resInports* := <set-index>(<subt>(portNum, 1), Input([IntPair("1", "1")]), newInports*);
				resOutports* := <map(intpair-addX(|1))> outports*;
				resSize := <intpair-addY(|32)> size
			end end end
	
	add-lin-out-mirror(|mods*, outports*, size, modNum, portNum):
		Block(loc, rot, mir) -> (resMods*, resOutports*, resSize)
		with
			newRot := <mod>(<add>(<mul>(<string-to-int>mir, 180), <string-to-int>rot), 360);
			if <eq> (newRot, 270) then
				<debug>"Cannot map linear skeleton with modules with outports on the opposide side of the first output port."
			else if <eq> (newRot, 90) then
				resMods* := mods*;
				resOutports* := outports*;
				resSize := size
			else if <eq> (newRot, 0) then
				newMods* := <map(increase-module-num-by(gt|1, 0))> mods*;
				thisMod := <index(|modNum)> newMods*;
				newMod := <module-set-source(|portNum, IntPair("1", "1"))> thisMod;
				newerMods* := <set-index>(<dec> modNum, newMod, newMods*);
				resMods* := <add-mirror(|loc, "180", "0", <tuple-to-intpair>(0, portNum), <index(|modNum)> newerMods*)> newerMods*;
				resOutports* := <set-index>(<subt>(portNum, 1), IntPair(<add; int-to-string>(<length> mods*, 1), "1"), outports*);
				resSize := <intpair-addY(|32)> size
			else
				newMods* := <map(increase-module-num-by(gt|1, 0))> mods*;
				thisMod := <index(|modNum)> newMods*;
				newMod := <module-set-source(|portNum, IntPair("1", "1"))> thisMod;
				newerMods* := <set-index>(<dec> modNum, newMod, newMods*);
				resMods* := <add-mirror(|loc, "180", "1", <tuple-to-intpair>(0, portNum), <index(|modNum)> newerMods*)>newerMods*;
				resOutports* := <set-index>(<subt>(portNum, 1), IntPair(<add; int-to-string>(<length> mods*, 1), "1"), outports*);
				resSize := <intpair-addY(|32)> size
			end end end	
			
	/*
		Function that adds mirrors between one output port and a number of conne cted input ports
		inputs:
			list of modules on the side of the input ports: the mirrors will be added here and these modules need to be updated depending on the amount of mirrors added
			amount of mirrors added to the input list before the start of this rule
			number representing what input of the system from which the modules come, was used to find the connection to which now mirrors are added.
			inputs of the system
			outputs of the other system the current system is being connected to
			amount of modules in the other system
			amount of modules in the other system, but 0 if the this system is not yet connected to that system.
			The port the new mirrors should be connected to.
	*/
			
	add-mirrors(|mods*, mirNum, inputNum, inputs*, outputs*, addModRef, modNum1, connectPort):
		(outPortBlock, inPortBlocks*) -> (resMods*, resInputs*, resOutputs*)
		with
			outOrientation := <block-get-orientation> outPortBlock;
			inOrientations* := <map(block-get-orientation)> inPortBlocks*;
			orientationDiffs* := <zip(subt)>(<copy>(<length> inOrientations*, outOrientation), inOrientations*);
			outBL := <block-get-bottom-left(|IntPair("32","1"))> outPortBlock;
			inBLs* := <map(block-get-bottom-left(|IntPair("32","1")))> inPortBlocks*;

			if <eq>(<length> inPortBlocks*, 1) then
				currentInput := <index(|inputNum); input-get-inputs; index(|1)> inputs*;
				if <intpair-are-alligned>(outBL, <index(|1)> inBLs*) then
					if <eq>(<index(|1)> orientationDiffs*, 2) then
						(resMods*, resInputs*, resOutputs*) := (mods*, inputs*, outputs*)
					else
						(resMods*, addMirNum) := <place-mirror(|mods*, mirNum, <intpair-getx; string-to-int> currentInput,  <intpair-gety; string-to-int> currentInput, addModRef, modNum1, connectPort)>(outOrientation, <index(|1)> orientationDiffs*, outBL, <index(|1)> inBLs*);
						newInputs* := <map(input-addx-to-all(|addMirNum, 0))> inputs*;
						resInputs* := <set-index>(<dec>inputNum, Input([IntPair(<addS>("1", <int-to-string> addModRef), "1")]), newInputs*);
						resOutputs* := <map(intpair-addX-cond(gt|addMirNum, 0))> outputs*
					end
				else
					 (resMods*, addMirNum) := <place-mirror(|mods*, mirNum, <intpair-getx; string-to-int> currentInput,  <intpair-gety; string-to-int> currentInput, addModRef, modNum1, connectPort)>(outOrientation, <index(|1)> orientationDiffs*, outBL, <index(|1)> inBLs*);
					 newInputs* := <map(input-addx-to-all(|addMirNum, 0))> inputs*;
					 resInputs* := <set-index>(<dec>inputNum, Input([IntPair(<addS>("1", <int-to-string> addModRef), "1")]), newInputs*);
					 resOutputs* := <map(intpair-addX-cond(gt|addMirNum, 0))> outputs*
				end
			else
				currentInputs* := <index(|inputNum); input-get-inputs> inputs*;
				startInputs* := <set-index>(<dec>inputNum, Input([]), inputs*);
				(resMods*, resInputs*, resOutputs*) := <place-mirrors(|mods*, mirNum, inputNum, startInputs*, outputs*, addModRef, modNum1, 0, connectPort)>(outOrientation, orientationDiffs*, outBL, inBLs*, currentInputs*)
			end
			
	place-mirrors(|mods*, mirNum, inputNum, inputs*, outputs*, addModRef, modNum1, addedMirs, connectPort):
		(outOrientation, [diff | orientationDiffs*], outBL, [inBL | inBLs*], [thisInput | theseInputs*]) -> (resMods*, resInputs*, resOutputs*)
		with
			(newMods*, addMirNum) := <place-mirror(|mods*, mirNum, <add>(<intpair-getx; string-to-int> thisInput, addedMirs), <intpair-gety; string-to-int> thisInput, addModRef, modNum1, connectPort)> (outOrientation, diff, outBL, inBL);
			newInputs* := <map(input-addx-to-all(|addMirNum, 0))> inputs*;
			currentInput := <index(|inputNum)> newInputs*;
			newInput := <input-add-intpairs(|[IntPair(<addS>("1", <int-to-string> addModRef), "1")])> currentInput;
			newerInputs* := <set-index>(<dec> inputNum, newInput, newInputs*);
			newOutputs* := <map(intpair-addX-cond(gt|addMirNum, 0))> outputs*;
			(resMods*, resInputs*, resOutputs*) := <place-mirrors(|newMods*, mirNum, inputNum, newerInputs*, newOutputs*, addModRef, modNum1, <add>(addedMirs, addMirNum), connectPort)>(outOrientation, orientationDiffs*, outBL, inBLs*,  theseInputs*)
	
	place-mirrors(|mods*, mirNum, inputNum, inputs*, outputs*, addModRef, modNum1, addedMirs, connectPort):
		(outOrientation, [], outBL, [], []) -> (mods*, inputs*, outputs*)
	
	
	place-mirror(|mods*, mirNum, modNum, portNum, addModRef, modNum1, connectPort):
		(outOrientation, orientationDiff, outPos, inPos) -> (resMods*, addMirNum)
		with
			if <eq>(orientationDiff, 0)  then
				if <eq>(outOrientation, 0) then
					mir1Rot := "0";
					mir1X := <intpair-getx> inPos;
					mir1Y := <subt; int-to-string>(<min>(<intpair-gety; string-to-int> outPos, <intpair-gety; string-to-int> inPos), <mul>(mirNum, 32));
					mir2X := <addS>(<intpair-getx> outPos, "32");
					mir2Y := mir1Y;
					mir2Rot := "270"
				else if <eq>(outOrientation, 1) then
					mir1Rot := "90";
					mir1X := <add; int-to-string>(<max>(<intpair-getx; string-to-int> outPos, <intpair-getx; string-to-int> inPos), <mul>(mirNum, 32));
					mir1Y := <intpair-gety> inPos;
					mir2X := mir1X;
					mir2Y := <addS>(<intpair-gety> outPos, "32");
					mir2Rot := "0"
				else if <eq>(outOrientation, 2) then
					mir1Rot := "180";
					mir1X := <addS>(<intpair-getx> inPos, "32");
					mir1Y := <add; int-to-string>(<max>(<intpair-gety; string-to-int> outPos, <intpair-gety; string-to-int> inPos), <mul>(mirNum, 32));
					mir2X := <intpair-getx> outPos;
					mir2Y := mir1Y;
					mir2Rot := "90"
				else
					mir1Rot := "270";
					mir1X := <subt; int-to-string>(<min>(<intpair-getx; string-to-int> outPos, <intpair-getx; string-to-int> inPos), <mul>(mirNum, 32));
					mir1Y := <addS>(<intpair-gety> inPos, "32");
					mir2X := mir1X;
					mir2Y := <intpair-gety> outPos;
					mir2Rot := "180"
				end end end;
				addMirNum := 2;
				newMods* := <map(increase-module-num-by(gt|2, modNum1))> mods*;
				thisMod := <index(|<subt>(modNum, modNum1))> newMods*;
				newMod := <module-set-source(|portNum, IntPair(<addS>("2", <int-to-string> addModRef), "1"))> thisMod;
				newerMods* := <set-index>(<subt; dec>(modNum, modNum1), newMod, newMods*);
				mir1Mods* := <add-mirror(|IntPair(mir1X, mir1Y), mir1Rot, "1", <tuple-to-intpair>(<inc> addModRef, 1), <index(|<subt>(modNum, modNum1))> newerMods*)> newerMods*;
				resMods* := <add-mirror(|IntPair(mir2X, mir2Y), mir2Rot, "1", connectPort, <index(|<subt>(modNum, modNum1))> newerMods*)> mir1Mods*
			else if <eq>(<abs> orientationDiff, 2)  then
				if <eq>(outOrientation, 0) then
					mir1Rot := "180";
					mir1X := <addS>(<intpair-getx> inPos, "32");
					mir1Y := <add; int-to-string>(<intpair-gety; string-to-int> outPos, <mul>(<subt>(mirNum, 1), 32));
					mir2X := <subtS>(<intpair-getx> outPos, "32");
					mir2Y := <addS>(mir1Y, "32");
					mir2Rot := "270"
				else if <eq>(outOrientation, 1) then
					mir1Rot := "270";
					mir1X := <add; int-to-string>(<intpair-getx; string-to-int> outPos, <mul>(<add>(mirNum, 1), 32));
					mir1Y := <addS>(<intpair-gety> inPos, "32");
					mir2X := <subtS>(mir1X, "32");
					mir2Y := <intpair-gety> outPos;
					mir2Rot := "0"
				else if <eq>(outOrientation, 2) then
					mir1Rot := "0";
					mir1X := <intpair-getx> inPos;
					mir1Y := <add; int-to-string>(<intpair-gety; string-to-int> outPos, <mul>(<add>(mirNum, 1), 32));
					mir2X := <addS>(<intpair-getx> outPos, "32");
					mir2Y := <subtS>(mir1Y, "32");
					mir2Rot := "90"
				else
					mir1Rot := "90";
					mir1X := <add; int-to-string>(<intpair-getx; string-to-int> outPos, <mul>(mirNum, 32));
					mir1Y := <intpair-gety> inPos;
					mir2X := <addS>(mir1X, "32");
					mir2Y := <addS>(<intpair-gety> outPos, "32");
					mir2Rot := "180"
				end end end;
				addMirNum := 2;
				newMods* := <map(increase-module-num-by(gt|2, modNum1))> mods*;
				thisMod := <index(|<subt>(modNum, modNum1))> newMods*;
				newMod := <module-set-source(|portNum, IntPair(<addS>("2", <int-to-string> addModRef), "1"))> thisMod;
				newerMods* := <set-index>(<subt; dec>(modNum, modNum1), newMod, newMods*);
				mir1Mods* := <add-mirror(|IntPair(mir1X, mir1Y), mir1Rot, "1", <tuple-to-intpair>(<inc> addModRef, 1), <index(|<subt>(modNum, modNum1))> newerMods*)> newerMods*;
				resMods* := <add-mirror(|IntPair(mir2X, mir2Y), mir2Rot, "0", connectPort, <index(|<subt>(modNum, modNum1))> newerMods*)> mir1Mods*
			else
				if <eq>(outOrientation, 0) then
					mirX := <addS>(<intpair-getx> outPos, "32");
					mirY := <addS>(<intpair-gety> inPos, "32")
				else if <eq>(outOrientation, 1) then
					mirX := <intpair-getx> inPos;
					mirY := <addS>(<intpair-gety> outPos, "32")
				else if <eq>(outOrientation, 2) then
					mirX := <intpair-getx> outPos;
					mirY := <intpair-gety> inPos
				else
					mirX :=  <addS>(<intpair-getx> inPos, "32");
					mirY := <intpair-gety> outPos
				end end end;
				mirRot := <int-to-string>(<mod>(<add>(<mul>(outOrientation, 90), 270), 360));
				addMirNum := 1;
				newMods* := <map(increase-module-num-by(gt|1, modNum1))> mods*;
				thisMod := <index(|<subt>(modNum, modNum1))> newMods*;
				newMod := <module-set-source(|portNum, IntPair(<addS>("1", <int-to-string> addModRef), "1"))> thisMod;
				newerMods* := <set-index>(<subt; dec>(modNum, modNum1), newMod, newMods*);
				resMods* := <add-mirror(|IntPair(mirX, mirY), mirRot, "1", connectPort, <index(|<subt>(modNum, modNum1))> newerMods*)> newerMods*
			end end
					
	add-mirror(|loc, rot, mir, source, currentMod):
		mods* -> resMods*
		with
			block := Block(loc, rot, mir);
			time := <module-get-start> currentMod;
			newMod* := [Module("-1", time, block, [source])];
			resMods* := [newMod*, mods*]	
		
	skeleton-get-linear-system(|ast, systemTuples*, skeletonList*):
		LibModNum(str) -> <ast-to-dfg(|ast, systemTuples*, skeletonList*); rotate-outport(|ast); add-lin-mirrors(|ast); system-move-to-origin(|ast)> LibModNum(str) 
			  
	skeleton-get-linear-system(|ast, systemTuples*, skeletonList*):
		Connect(skel, Linear(), r) -> sys
		with
			preSys := <skeleton-get-linear-system(|ast, systemTuples*, skeletonList*)> skel
			; postSys := <skeleton-get-linear-system(|ast, systemTuples*, skeletonList*)> r
			; sys := <connect-in-X(|ast)> (preSys, postSys)
			  
	skeleton-get-linear-system(|ast, systemTuples*, skeletonList*):
		[skel | skels*] -> sys
		with
		thisSys := <skeleton-get-linear-system(|ast, systemTuples*, skeletonList*)> skel;
		if <geq>(<length> skels*, 1) then
			thatSys := <skeleton-get-linear-system(|ast, systemTuples*, skeletonList*)> skels*;
			sys := <combine-in-Y(|ast)> (thisSys, thatSys)
		else
			sys := thisSys
		end
	
	skeleton-get-linear-system(|ast, systemTuples*, skeletonList*):
		VarRef(val) -> sys
		with
			sys := <ast-to-dfg(|ast, systemTuples*, skeletonList*)> VarRef(val)
	
	skeleton-get-linear-system(|ast, systemTuples*, skeletonList*):
		Nop() -> <ast-to-dfg(|ast, systemTuples*, skeletonList*)> Nop()
		
	skeleton-get-linear-system(|ast, systemTuples*, skeletonList*):
		CompRef(x, sizes) -> <lookup>(x, systemTuples*)
		
	skeleton-get-input-length(|ast):
		Nop() -> 1
		
	skeleton-get-input-length(|ast):
		LibModNum(num) -> res
		with
			res := <get-libmod(|<string-to-int> num); libmod-get-input-num> ast
		
	skeleton-get-input-length(|ast):
		Connect(skel1, _, _) -> <skeleton-get-input-length(|ast)> skel1
	
	skeleton-get-input-length(|ast):
		CompRef(system, (insize, outsize)) -> insize
		
	skeleton-get-input-length(|ast):
		skels* -> res
		with
			skelRes* := <map(skeleton-get-input-length(|ast))> skels*;
			res := <foldl(add)>(skelRes*, 0)
			
	skeleton-get-output-length(|ast):
		Nop() -> 1
		
	skeleton-get-output-length(|ast):
		LibModNum(num) -> res
		with
			res := <get-libmod(|<string-to-int> num); libmod-get-output-num> ast
		
	skeleton-get-output-length(|ast):
		Connect(_, _, skel2) -> <skeleton-get-output-length(|ast)> skel2 
		
	skeleton-get-output-length(|ast):
		CompRef(system, (insize, outsize)) -> outsize
		
	skeleton-get-output-length(|ast):
		skels* -> res
		with
			skelRes* := <map(skeleton-get-output-length(|ast))> skels*;
			res := <foldl(add)>(skelRes*, 0)
	
	merge-trees:
		([], [], [], []) -> sys*
		with
			sys* := []
			
	merge-trees:
		([], [], thatSys*, thatN*) -> sys*
		with
			sys* := thatSys*
		
	merge-trees:
		(thisSys*, thisN*, [], []) -> sys*
		with
			sys* := thisSys*
			
	merge-trees:
		(thisSys*, thisN*, thatSys*, thatN*) -> sys*
		with
			thisSize := <length> thisSys*;
			thatSize := <length> thatSys*;

			[thisStageSize] := <take(|1)> thisN*;
			thisStageSys* := <take(|thisStageSize)> thisSys*;
			thisRestStages* := <drop(|thisSize)> thisSys*;
			thisRestN* := <drop(|1)> thisN*;
			
			[thatStageSize] := <take(|1)> thatN*;
			thatStageSys* := <take(|thatStageSize)> thatSys*;
			thatRestStages* := <drop(|thatSize)> thatSys*;
			thatRestN* := <drop(|1)> thatN*;
		
			stageSys* := [thisStageSys*, thatStageSys*];
			restStagesSys* := <merge-trees>(thisRestStages*, thisRestN*, thatRestStages*, thatRestN*);
			sys* := [ stageSys*, restStagesSys*]		