module module-trans

imports

  libstratego-gpp
  lib/runtime/tmpl/pp
  src-gen/signatures/Module-sig
  src-gen/signatures/Block-sig
  src-gen/signatures/IntPair-sig
  block-trans
  helper
  intpair-trans
  program-trans
  libmod-trans
  system-trans

rules
	module-get-block:
		Module(modId, _, block, _) -> block
	
	module-get-id:
		Module(modId, _, _, _) -> modId
	
	module-get-start:
		Module(_, time, _, _) -> time
	
  /**
   * Repete Module list n times, with each time increase the Y coordinate of position by size.y
   *
   * Example: module-shift-with-indices(|3, (80,100)) [(0,0),(100,0)]
   * => [(0,0),(100,0),(0,100),(100,100),(0,200),(100,200)]
   * the example only show member variable "position" of a module for concision
   *
   * @type List(Module) -> List(Module)
   */
	module-shift-with-indices(|n, size):
		module* -> new*
		with
	    	temp* := <copy>(n, module*)
	    	; sizeY := <intpair-gety; string-to-int> size
	    	; shiftY := <natural; map(int-mul(|sizeY))> n
	    	; new* := <zip(module-shiftY-for-list); flatten-list> (temp*, shiftY)
	 
	  module-shiftX-for-list:
	 	(module*, shiftX) -> <map(module-shiftX(|shiftX))> module*
	 	   	  
	 module-shiftY-for-list:
	 	(module*, shiftY) -> <map(module-shiftY(|shiftY))> module*
	 	
	 module-shiftX(|shiftX):
	 	Module(modId, time, block, source*) -> Module(modId, time, newblock, source*)
		with
			newblock := <block-shiftX(|shiftX)>block
			
	 module-shiftY(|shiftY):
	 	Module(modId, time, block, source*) -> Module(modId, time, newblock, source*)
		with
			newblock := <block-shiftY(|shiftY)>block
			
	module-rotate(|angle):
		Module(modId, time, block, source*) -> Module(modId, time, newblock, source*)
		with
			newblock := <block-rotate(|angle)> block
			
	module-flip:
		Module(modId, time, block, source*) -> Module(modId, time, newblock, source*)
		with
			newblock := <block-mirror> block
			
	module-reorientate-at-origin(|rot, mir):
		Module(modId, time, block, source*) -> Module(modId, time, newBlock, source*)
		with	
			newBlock := <block-rotate-around-origin(|rot); block-flip-in-X(|mir)> block

	module-get-libmod(|ast):
		Module(modId, _, _, _) -> <get-libmod(|<string-to-int>modId)> ast
		
	modules-transform:
		(mod*, block) -> <map(module-transform(|block))> mod*
	
	module-transform(|tb):
	 	Module(modId, time, block, source*) -> Module(modId, time, <block-inherit(|tb)>block, source*)
	
	module-delay(|latency):
		Module(modId, time, block, source*) -> Module(modId, newTime, block, source*)
		with
			newTime := <add; int-to-string>(<string-to-int>time, latency)
			
	module-get-sources:
		Module(modId, time, block, sources*) -> sources*	
		
	module-remove-source(|num):
		Module(modId, time, block, sources*) -> Module(modId, time, block, newSources*)
		with
			newSource := <index(|num); intpair-setx(|0)> sources*;
			newSources* := <set-index> (<subt> (num, 1), newSource, sources*)
	
	module-add-source(|modNum, portNum):
		Module(modId, time, block, source*) -> Module(modId, time, block, newSource*)
		with
			newElem* := [IntPair(<int-to-string> modNum, <int-to-string> portNum)];
			newSource* := [source* | newElem*]
			
	module-add-sources(|newSources*):
		Module(modId, time, block, sources*) -> Module(modId, time, block, resSources*)
		with
			resSources* := [sources*, newSources*]
			
	module-replace-source(|toReplace, replaceWith):
	Module(modId, time, block, sources*) -> Module(modId, time, block, newSources*)
	with
		newSources* := <map(intpair-replace(|toReplace, replaceWith))> sources*
		
	module-set-source(|index, source):
	Module(modId, time, block, sources*) -> Module(modId, time, block, newSources*)
	with
		length := <length> sources*;
		if <gt> (index, length) then
			emptySources* := <copy> (<subt>(<subt> (index, length), 1), IntPair("0", "0"));
			newSource* := [source];
			newSources* := [sources*, emptySources*, newSource*]
		else
			newSources* := <set-index> (<subt> (index, 1), source, sources*)
		end
	
	module-set-in-source(|sourceNum, inNum):
		Module(modId, time, block, sources*) -> Module(modId, time, block, newSources*)
		with
			length := <length> sources*;
			if <gt> (sourceNum, length) then
				emptySources* := <copy> (<subt; dec> (sourceNum, length), IntPair("0", "0"));
				newSource* := [IntPair("0", <int-to-string> inNum)];
				newSources* := [sources*, emptySources*, newSource*]
			else
				newSources* := <set-index>(<dec> sourceNum, IntPair("0", <int-to-string> inNum), sources*)
			end
	
	modules-shift-to-origin(|ast):
		mod* -> newmod*
		with
			bl := <modules-get-bottom-left(|ast)> mod*
			; block := Block(<intpair-neg>bl, "0", "0")
			; newmod* := <modules-transform> (mod*, block)
	
	modules-get-bottom-left(|ast):
		mod* -> bl
		with
			list* := <map(module-get-bottom-left(|ast))> mod*
			; bl := <intpairs-get-bottom-left> list*
	
	module-get-bottom-left(|ast):
		Module(modId, time, block, _) -> bl
		with
			libmod := <get-libmod(|<string-to-int>modId)> ast
			; size := <libmod-get-size> libmod
			; bl := <block-get-bottom-left(|size)> block
	
	modules-get-top-right(|ast):
		mod* -> tr
		with
			list* := < map(module-get-top-right(|ast))> mod*
			; tr := <intpairs-get-top-right> list*
	
	module-get-top-right(|ast):
		Module(modId, time, block, _) -> tr
		with
			libmod := <get-libmod(|<string-to-int>modId)> ast
			; size := <libmod-get-size> libmod
			; tr := <block-get-top-right(|size)> block
			
	modules-link-by-intpairs:
		(mod*, input*, pair*) -> <foldl(modules-link-by-intpair)> (<zip>(input*, pair*), mod*)
	
	modules-link-by-intpair:
		((input, pair), mod*) -> newmod*
		with
			n := <intpair-getx; string-to-int> input
			; new := <index(|n); module-link(|<intpair-gety>input, pair)> mod*
			; newmod* := <conc> (<take(|<subt>(n,1))> mod*, [new], <drop(|n)> mod*)
			  
	module-link(|num, pair):
		Module(modId, time, block, source*) -> Module(modId, time, block, newsrc*)
		with
			len := <length> source*
			; n := <string-to-int> num
			; diff := <subt> (n, <inc>len)
			; if <gt> (diff, 0)
			  then newsrc* := <conc> (source*, <copy>(diff, IntPair("0", "0")), [pair])
			  else if <gt> (diff, -1) // diff==0, which means n==len+1
			       then newsrc* := <conc> (source*, [pair])
			       else newsrc* := <conc> (<take(|<subt>(n,1))> source*, [pair], <drop(|n)> source*)
			       end
			  end
	
	modules-copy(|n):
		mod* -> newmod*
		with
	    	temp* := <copy>(n, mod*)
	    	; list* := <natural; map(int-mul(|<length>mod*))> n
	    	; newmod* := <zip(increase-modules-num-by)> (temp*, list*)
	    	  
	module-unmark-source:
		Module(modId, time, block, source*) -> Module(modId, time, block, newsrc*)
		with
			newsrc* := <map(intpair-unmark)> source*
